package paillier

import (
	"crypto/rand"
	"crypto/sha256"
	"math/big"

	"github.com/cronokirby/saferith"
	"github.com/fxamacker/cbor/v2"
	"github.com/mr-shifu/mpc-lib/core/math/arith"
	"github.com/mr-shifu/mpc-lib/core/math/sample"
	pailliercore "github.com/mr-shifu/mpc-lib/core/paillier"
	"github.com/mr-shifu/mpc-lib/core/pool"
	cs_pedersen "github.com/mr-shifu/mpc-lib/pkg/common/cryptosuite/pedersen"
	"github.com/mr-shifu/mpc-lib/pkg/cryptosuite/sw/pedersen"
)

type PaillierKeyImpl struct {
	secretKey *pailliercore.SecretKey
	publicKey *pailliercore.PublicKey
}

type rawPaillierKey struct {
	SecretKey []byte
	PublicKey []byte
}

var _ PaillierKey = (*PaillierKeyImpl)(nil)

func NewPaillierKeyImpl(sk *pailliercore.SecretKey, pk *pailliercore.PublicKey) PaillierKeyImpl {
	return PaillierKeyImpl{sk, pk}
}

// Bytes returns the binary encoded of N param of public key secret key params (P, Q) if exists.
// The encoded data is structured as follows:
// | N length | N | SecretKey Length | P Length | P | Q length | Q |
func (k *PaillierKeyImpl) Bytes() ([]byte, error) {
	raw := &rawPaillierKey{}

	if k.Private() {
		sb, err := k.secretKey.MarshalBinary()
		if err != nil {
			return nil, err
		}
		raw.SecretKey = sb
	}

	pkb, err := k.publicKey.N().MarshalBinary()
	if err != nil {
		return nil, err
	}
	raw.PublicKey = pkb

	return cbor.Marshal(raw)
}

// SKI returns the Subject Key Identifier of the key derived from N param of public key.
func (k *PaillierKeyImpl) SKI() []byte {
	// TODO: we should make sure that N param is unique for each key to derive SKI from it.
	pbs := k.ParamN().Bytes()
	if pbs == nil {
		return nil
	}
	hash := sha256.New()
	hash.Write(pbs)
	return hash.Sum(nil)
}

// Private returns true if the key contains secret key.
func (k *PaillierKeyImpl) Private() bool {
	return k.secretKey != nil
}

// PublicKey returns the public key part of the key.
func (k *PaillierKeyImpl) PublicKey() PaillierKey {
	return &PaillierKeyImpl{nil, k.publicKey}
}

func (k *PaillierKeyImpl) PublicKeyRaw() *pailliercore.PublicKey {
	return k.publicKey
}

// Modulus returns the modulus of the key.
func (k *PaillierKeyImpl) Modulus() *arith.Modulus {
	return k.publicKey.Modulus()
}

// ParamN returns the N param of the key.
func (k *PaillierKeyImpl) ParamN() *saferith.Modulus {
	return k.publicKey.N()
}

// Encrypt returns the encryption of `message` as ciphertext and nonce generated by function.
func (k *PaillierKeyImpl) Encode(m *saferith.Int) (*pailliercore.Ciphertext, *saferith.Nat) {
	return k.publicKey.Enc(m)
}

// EncryptWithNonce returns the encryption of `message` as ciphertext and nonce passed to function.
func (k *PaillierKeyImpl) EncWithNonce(m *saferith.Int, nonce *saferith.Nat) *pailliercore.Ciphertext {
	return k.publicKey.EncWithNonce(m, nonce)
}

// Decrypt returns the decryption of `ct` as ciphertext.
func (k *PaillierKeyImpl) Decode(ct *pailliercore.Ciphertext) (*saferith.Int, error) {
	return k.secretKey.Dec(ct)
}

// DecryptWithNonce returns the decryption of `ct` as ciphertext and nonce.
func (k *PaillierKeyImpl) DecodeWithNonce(ct *pailliercore.Ciphertext) (*saferith.Int, *saferith.Nat, error) {
	return k.secretKey.DecWithRandomness(ct)
}

// ValidateCiphertexts returns true if all ciphertexts are valid.
func (k *PaillierKeyImpl) ValidateCiphertexts(cts ...*pailliercore.Ciphertext) bool {
	return k.publicKey.ValidateCiphertexts(cts...)
}

// Derive Pedersen Key from Paillier Key prime factors
func (k *PaillierKeyImpl) DerivePedersenKey() (cs_pedersen.PedersenKey, error) {
	pk, sk := k.secretKey.GeneratePedersen()
	return pedersen.NewPedersenKey(sk, pk), nil
}

// Sample returns a random number in [1, N-1] and its multiplication by t; (a, A = t^a mod N).
func (k *PaillierKeyImpl) Sample(t *saferith.Nat) (*saferith.Nat, *big.Int) {
	phi := saferith.ModulusFromNat(k.secretKey.Phi())

	lockedRand := pool.NewLockedReader(rand.Reader)

	a := sample.ModN(lockedRand, phi)

	A := k.Modulus().Exp(t, a).Big()

	return a, A
}

// fromBytes returns a Paillier key from its binary encoded data.
func fromBytes(data []byte) (*PaillierKeyImpl, error) {
	// nlb := data[:2]
	// nl := binary.LittleEndian.Uint16(nlb)
	// if nl == 0 {
	// 	return PaillierKeyImpl{}, nil
	// }
	// nb := data[2 : nl+2]

	// // decode public key Modulus N
	// n := new(saferith.Modulus)
	// if err := n.UnmarshalBinary(nb); err != nil {
	// 	return PaillierKeyImpl{}, err
	// }
	// pk := pailliercore.NewPublicKey(n)

	// // if secret key exists then decode secret key params (P, Q)
	// slb := data[nl+2 : nl+4]
	// sl := binary.LittleEndian.Uint16(slb)
	// if sl == 0 {
	// 	return PaillierKeyImpl{publicKey: pailliercore.NewPublicKey(n)}, nil
	// }

	// // decode secret key params (P, Q)
	// sb := data[nl+4 : nl+4+sl]
	// sk := new(pailliercore.SecretKey)
	// if err := sk.UnmarshalBinary(sb); err != nil {
	// 	return PaillierKeyImpl{}, err
	// }

	key := &PaillierKeyImpl{}

	raw := &rawPaillierKey{}
	if err := cbor.Unmarshal(data, raw); err != nil {
		return nil, err
	}

	n := new(saferith.Modulus)
	if err := n.UnmarshalBinary(raw.PublicKey); err != nil {
		return nil, err
	}
	key.publicKey = pailliercore.NewPublicKey(n)

	if raw.SecretKey != nil {
		sk := new(pailliercore.SecretKey)
		if err := sk.UnmarshalBinary(raw.SecretKey); err != nil {
			return nil, err
		}
		key.secretKey = sk
	}

	return key, nil
}
